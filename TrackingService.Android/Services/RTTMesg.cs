using System;
using System.Text;
using System.Collections.Generic;
using System.Collections.ObjectModel;

using CANLib;

namespace Tracking.Services
{
	public class RTTMesg
	{
#if ANDROID
        public static log4droid CNXLog = new log4droid() { Logger = "CNXLogger" };
#else
        public static log4net.ILog CNXLog = log4net.LogManager.GetLogger("CNXLogger");
#endif
        /// <summary>
        /// messages less than this treshold are direct CAN messages.
        /// </summary>
        public const uint CANMesgThreshold = 0x1000;

		/// <summary>
		/// Ids for incomming messages from the server
		/// </summary>
		public enum RTTInMsgIds : uint
		{
			/// <summary>
			/// Lists firmware versions loaded in the RTT system
			/// </summary>
			FirmwareBuildNos = 0x1001,
			/// <summary>
			/// Lists resource versions generated by the RTT system
			/// </summary>
			ResourceBuildNos = 0x1002,
			/// <summary>
			/// Provides the company tag for the vehicle.
			/// </summary>
			CompanyTag = 0x1003,
			/// <summary>
			/// Acknowledgement to driver logon
			/// </summary>
			DriverLogonOK = 0x1004,
			/// <summary>
			/// Acknowledgement to driver logon
			/// </summary>
			DriverLogonFail = 0x1005,
			/// <summary>
			/// force a driver logoff
			/// </summary>
			DriverLogoff = 0x1006,
			/// <summary>
			/// Txt message from the server to the driver.
			/// </summary>
			DriverMesg2 = 0x1007,
			VehicleInfo = 0x1008,
			/// <summary>
			/// Flush APC files.
			/// </summary>
			FlushData = 0x1009,
		};

		/// <summary>
		/// Ids for outgoing messages to the server
		/// </summary>
		public enum RTTOutMsgIds : ushort
		{
			/// <summary>
			/// No communication from GPS.
			/// </summary>
			UNKNOWN = 0x0000,
			/// <summary>
			/// No communication from GPS.
			/// </summary>
			GPSNone = 0xf000,
			/// <summary>
			/// GPS reporting no fix.
			/// </summary>
			GPSNoFix = 0xf001,
			/// <summary>
			/// GPS reporting fix with very large error estimate.
			/// </summary>
			GPSBadFix = 0xf002,
			/// <summary>
			/// GPS reporting good fix.
			/// </summary>
			GPSGoodFix = 0xf003,
			/// <summary>
			/// Equipment status.
			/// </summary>
			EquipmentStatus = 0xf010,
			/// <summary>
			/// Firmware build numbers.
			/// </summary>
			FirmwareBuildNo = 0xf011,
			/// <summary>
			/// Vehicle resource versions.
			/// </summary>
			ResourceBuildNo = 0xf012,
			/// <summary>
			/// Logs the driver off.
			/// </summary>
			DriverLogoff = 0xf020,
			/// <summary>
			/// Logs the driver on.
			/// </summary>
			DriverLogon = 0xf021,
			/// <summary>
			/// Set the driver status.
			/// </summary>
			DriverStatusNormal = 0xf022,
			/// <summary>
			/// Set the driver status.
			/// </summary>
			DriverStatusOnBreak = 0xf023,
			/// <summary>
			/// Set the driver status.
			/// </summary>
			DriverStatusOutOfVehicle = 0xf024,
			/// <summary>
			/// Txt message to the server
			/// </summary>
			DriverMesg = 0xf025,
			/// <summary>
			/// Acknowledgement to a previous server text message.
			/// </summary>
			DriverMesgAck = 0xf026,
			/// <summary>
			/// Realtime passenger loading.
			/// </summary>
			APCLoading = 0xf00a,
		};

		protected const int GPSNoneLen = 6;
		protected const int GPSNoFixLen = 6;
		protected const int GPSBadFixLen = 6;
		protected const int GPSGoodFixLen = 15;
		protected const int EquipmentStatusLen = 6;
		protected const int FirmwareBuildNoLen = 4;
		protected const int ResourceBuildNoLen = 8;
		protected const int DriverLogoffLen = 4;
		protected const int DriverLogonLen = 4;
		protected const int DriverStatusNormalLen = 4;
		protected const int DriverStatusOnBreakLen = 4;
		protected const int DriverStatusOutOfVehicleLen = 4;
		protected const int DriverMesgLen = 4;
		protected const int DriverMesgAckLen = 7;
		protected const int APCLoadingLen = 5;

		/// <summary>
		/// Maximum TxT message length
		/// </summary>
		public const int MaxTxTMessageLen = 40;
		/// <summary>
		/// Maximum driver ID length
		/// </summary>
		public const int MaxDriverIdLen = 20;

		private static uint mAcceptableError = TrackingState.DefaultAcceptableError;
		/// <summary>
		/// The value used to determine whether a position is within accepatable limits in meters.
		/// </summary>
		public static uint AcceptableError
		{
			get { return mAcceptableError; }
			set { mAcceptableError = value; }
		}

		private double mLat = double.NaN;
		/// <summary>
		/// Current latitude in WGS84 decimal degrees. 
		/// </summary>
		public double Latitude { get { return mLat; } }

		private double mLong = double.NaN;
		/// <summary>
		/// Current longitude in WGS84 decimal degrees.
		/// </summary>
		public double Longitude { get { return mLong; } }

		private double mVelocity = double.NaN;
		/// <summary>
		/// Current horizontal velocity in meters/second.
		/// </summary>
		public double Velocity { get { return mVelocity; } }

		private uint mError = 0;
		/// <summary>
		/// Gets the GPS error.
		/// </summary>
		public uint Error { get { return mError; } }

		private bool mAlarm = false;
		/// <summary>
		/// Gets/Sets the alarm state.
		/// </summary>
		public bool Alarm
		{
			get { return mAlarm; }
			set { mAlarm = value; }
		}

		private string mTxTMessage;
		/// <summary>
		/// Gets/Sets the text message.
		/// </summary>
		public string TxTMessage
		{
			get { return mTxTMessage; }
			set { mTxTMessage = value; }
		}

		private string mDriverId;
		/// <summary>
		/// Gets/Sets the DriverId.
		/// </summary>
		public string DriverId
		{
			get { return mDriverId; }
			set { mDriverId = value; }
		}

		private ushort mMessageTag = 0;
		/// <summary>
		/// Gets/Sets the Message Acknowledgment Tag.
		/// </summary>
		public ushort MessageTag
		{
			get { return mMessageTag; }
			set { mMessageTag = value; }
		}

		private ReadOnlyCollection<DeviceCatalogueInfo> mCatalogue;
		/// <summary>
		/// Gets/Sets the device catalogue.
		/// </summary>
		public ReadOnlyCollection<DeviceCatalogueInfo> DeviceCatalogue
		{
			get { return mCatalogue; }
			set { mCatalogue = value; }
		}

		private DeviceCatalogueInfo.EquipmentFlages mEquipmentMask = DeviceCatalogueInfo.EquipmentFlages.None;
		private DeviceCatalogueInfo.EquipmentFlages mEquipmentState = DeviceCatalogueInfo.EquipmentFlages.None;
		public DeviceCatalogueInfo.EquipmentFlages EquipmentMask
		{
			get { return mEquipmentMask; }
			set { mEquipmentMask = value; }
		}
		public DeviceCatalogueInfo.EquipmentFlages EquipmentState
		{
			get { return mEquipmentState; }
			set { mEquipmentState = value; }
		}

		private byte mRoutePatternVersion = 255;
		/// <summary>
		/// Gets/Sets the route pattern resource version.
		/// </summary>
		public byte RoutePatternVersion
		{
			get { return mRoutePatternVersion; }
			set { mRoutePatternVersion = value; }
		}

		private byte mVehicleConfigVersion = 255;
		/// <summary>
		/// Gets/Sets the vehicle config resource version.
		/// </summary>
		public byte VehicleConfigVersion
		{
			get { return mVehicleConfigVersion; }
			set { mVehicleConfigVersion = value; }
		}

		private byte mServiceAlertVersion = 255;
		/// <summary>
		/// Gets/Sets the Service Alert resource version.
		/// </summary>
		public byte ServiceAlertVersion
		{
			get { return mServiceAlertVersion; }
			set { mServiceAlertVersion = value; }
		}

		private byte mDriverConfigVersion = 255;
		/// <summary>
		/// Gets/Sets the driver config resource version.
		/// </summary>
		public byte DriverConfigVersion
		{
			get { return mDriverConfigVersion; }
			set { mDriverConfigVersion = value; }
		}

		private byte mAPCLoading = 0;
		/// <summary>
		/// Gets/Sets the APC passenger loading.
		/// </summary>
		public byte APCLoading
		{
			get { return mAPCLoading; }
			set { mAPCLoading = value; }
		}

		private RTTOutMsgIds mMesgId = 0;
		/// <summary>
		/// Gets/Sets the message type/Id
		/// </summary>
		public RTTOutMsgIds MessageId
		{
			get { return mMesgId; }
			set { mMesgId = value; }
		}

		/// <summary>
		/// Indicates whether a message number needs to be sent to the server.
		/// </summary>
		public bool RequiresMesgNo { get { return !(mMesgId > RTTOutMsgIds.GPSGoodFix || mMesgId < RTTOutMsgIds.GPSNone); } }

		private byte mMesgNo = 0;
		/// <summary>
		/// The message number of this message.
		/// </summary>
		public byte MessageNumber
		{
			get { return mMesgNo; }
			set { mMesgNo = value; }
		}

		private ushort mCommsAddress = 0;
		/// <summary>
		/// The Comms address for this message.
		/// </summary>
		public ushort CommsAddress
		{
			get { return mCommsAddress; }
			set { mCommsAddress = value; }
		}

		private static byte CombineErrorAlarm(uint error, bool alarmActive)
		{
			byte combined = (error > (31 * 5)) ? (byte)31 : (byte)(error / 5);
			combined <<= 2;
			combined = (alarmActive) ? (byte)(combined | 0x80) : (byte)(combined & 0x7f);

			return combined;
		}

		/// <summary>
		/// Create a GPS message
		/// </summary>
		/// <param name="error">Error estimation</param>
		/// <param name="alarmActive">Alarm state</param>
		/// <returns>None GPS message</returns>
		public static RTTMesg CreateGPSNone(bool alarmActive)
		{
			RTTMesg mesg = new RTTMesg()
			{
				mMesgId = RTTOutMsgIds.GPSNone,
				mAlarm = alarmActive
			};
			return mesg;
		}

		/// <summary>
		/// Create a GPS message
		/// </summary>
		/// <param name="alarmActive">Alarm state</param>
		/// <returns>GPS message</returns>
		public static RTTMesg CreateGPSNoFix(bool alarmActive)
		{
			RTTMesg mesg = new RTTMesg()
			{
				mMesgId = RTTOutMsgIds.GPSNoFix,
				mAlarm = alarmActive
			};
			return mesg;
		}

		/// <summary>
		/// Create a GPS message
		/// </summary>
		/// <param name="error">Error estimation</param>
		/// <param name="alarmActive">Alarm state</param>
		/// <param name="latitude">Current latitude in WGS84 decimal degrees.</param>
		/// <param name="longitude">Current longitude in WGS84 decimal degrees.</param>
		/// <param name="velocity">Current horizontal velocity in meters/second.</param>
		/// <returns>GPS message</returns>
		/// <remarks>
		/// When the TrackingState is packed into a byte array to be used as an RTT message values may be truncated as follows: -
		/// Latitude/Longitude will be truncated to single presision floating point numbers.
		/// The error values is packed into 6 bits in 3 meter increments giving a maximum value of 208 meters.
		/// </remarks>
		public static RTTMesg CreateGPSFix(uint error, bool alarmActive, double latitude, double longitude, double velocity)
		{
			RTTMesg mesg = new RTTMesg();
			mesg.SetLocation(error, latitude, longitude, velocity);
			mesg.mAlarm = alarmActive;

			return mesg;
		}

		/// <summary>
		/// Create a Driver message
		/// </summary>
		/// <param name="messageTag">The message tag (cookie) supplied with the thessage that is being acknowledged</param>
		/// <returns>Driver message</returns>
		public static RTTMesg CreateDriverMessageAck(ushort messageTag)
		{
			RTTMesg mesg = new RTTMesg()
			{
				mMesgId = RTTOutMsgIds.DriverMesgAck,
				MessageTag = messageTag
			};
			return mesg;
		}

		/// <summary>
		/// Create a Driver message
		/// </summary>
		/// <param name="driverStatus">The status</param>
		/// <returns>Driver message</returns>
		public static RTTMesg CreateDriverStatus(RTTOutMsgIds driverStatus)
		{
			RTTMesg mesg = new RTTMesg()
			{
				mMesgId = driverStatus
			};
			return mesg;
		}

		/// <summary>
		/// Create a Driver message
		/// </summary>
		/// <param name="message">Text message for the server.</param>
		/// <returns>Driver message</returns>
		public static RTTMesg CreateDriverTxTMessage(string message)
		{
			RTTMesg mesg = new RTTMesg()
			{
				mMesgId = RTTOutMsgIds.DriverMesg,
				mTxTMessage = message
			};
			return mesg;
		}

		/// <summary>
		/// Create a Driver message
		/// </summary>
		/// <param name="id">Driver Id.</param>
		/// <returns>Driver message</returns>
		public static RTTMesg CreateDriverLogonMessage(string id)
		{
			RTTMesg mesg = new RTTMesg()
			{
				mMesgId = RTTOutMsgIds.DriverLogon,
				mDriverId = id
			};
			return mesg;
		}

		/// <summary>
		/// Create a Resource message
		/// </summary>
		/// <param name="catalogue">Device catalogue.</param>
		/// <returns>Resource message</returns>
		public static RTTMesg CreateEquipmentMessage(DeviceCatalogueInfo.EquipmentFlages mask, DeviceCatalogueInfo.EquipmentFlages state)
		{
			RTTMesg mesg = new RTTMesg()
			{
				mMesgId = RTTOutMsgIds.EquipmentStatus,
				mEquipmentMask = mask,
				mEquipmentState = state
			};
			return mesg;
		}

        /// <summary>
        /// Create a Resource message.
        /// </summary>
        /// <param name="catalogue">Device catalogue.</param>
        /// <returns>Resource message</returns>
        public static RTTMesg CreateFirmwareMessage(ReadOnlyCollection<DeviceCatalogueInfo> catalogue)
		{
			RTTMesg mesg = new RTTMesg()
			{
				mMesgId = RTTOutMsgIds.FirmwareBuildNo,
				mCatalogue = catalogue
			};
			return mesg;
		}

		/// <summary>
		/// Create a Resource message.
		/// </summary>
		/// <param name="routePatternVer">Route pattern resource version.</param>
		/// <param name="vehicleConfigVer">Vehicle config resource version.</param>
		/// <param name="ServiceAlertVer">Service alert resource version.</param>
		/// <param name="driverConfigVer">Driver config resource version.</param>
		/// <returns>Resource message.</returns>
		public static RTTMesg CreateResourceBuildMessage(byte routePatternVer, byte vehicleConfigVer, byte serviceAlertVer, byte driverConfigVer)
		{
			RTTMesg mesg = new RTTMesg()
			{
				mMesgId = RTTOutMsgIds.ResourceBuildNo,
				mRoutePatternVersion = routePatternVer,
				mVehicleConfigVersion = vehicleConfigVer,
				mServiceAlertVersion = serviceAlertVer,
				mDriverConfigVersion = driverConfigVer
			};
			return mesg;
		}

		/// <summary>
		/// Create a Loading message.
		/// </summary>
		/// <param name="loading">The loading of the vehicle</param>
		/// <returns>APCLoading message</returns>
		public static RTTMesg CreateAPCLoading(byte loading)
		{
			RTTMesg mesg = new RTTMesg()
			{
				mMesgId = RTTOutMsgIds.APCLoading,
				APCLoading = loading
			};
			return mesg;
		}

		/// <summary>
		/// Determines whether the message is populated with any valid version numbers.
		/// </summary>
		public bool IsResourceBuildPopulated
		{
			get
			{
				if (mRoutePatternVersion != 255)
					return true;
				if (mVehicleConfigVersion != 255)
					return true;
				if (mServiceAlertVersion != 255)
					return true;
				if (mDriverConfigVersion != 255)
					return true;
				return false;
			}
		}

		public void SetLocation(uint error, double latitude, double longitude, double velocity)
		{
			mLat = latitude;
			mLong = longitude;
			mVelocity = velocity;
			mError = error;

			mMesgId = (error > mAcceptableError) ? RTTOutMsgIds.GPSBadFix : RTTOutMsgIds.GPSGoodFix;

			// log bad fixes
			if (mMesgId == RTTOutMsgIds.GPSBadFix)
				CNXLog.ErrorFormat("GPS Precision {0}, {1}, {2}M", latitude, longitude, error * 3);
		}

		/// <summary>
		/// Gets the message as an array of bytes.
		/// </summary>
		/// <param name="encodeForWire">Whether to ensure the values conatined in the array are encoded for IP transmission (Big Endian).</param>
		public byte[] GetBytes(bool encodeForWire)
		{
			byte[] bytes = null;
			int index = 0;

			try
			{
				switch (mMesgId)
				{
					case RTTOutMsgIds.GPSNone:
					case RTTOutMsgIds.GPSNoFix:
						bytes = new byte[GPSNoneLen];
						index = BuildHeader(bytes, encodeForWire);
						bytes[index] = CombineErrorAlarm(0, mAlarm);
						break;
					case RTTOutMsgIds.GPSBadFix:
					case RTTOutMsgIds.GPSGoodFix:
						bytes = new byte[GPSGoodFixLen];
						index = BuildHeader(bytes, encodeForWire);
						bytes[index++] = CombineErrorAlarm(mError, mAlarm);
						// Latitude
						BitConverter.GetBytes((float)mLat).CopyTo(bytes, index);
						if (BitConverter.IsLittleEndian && encodeForWire)
							Array.Reverse(bytes, index, 4);
						index += 4;
						//Longitude
						BitConverter.GetBytes((float)mLong).CopyTo(bytes, index);
						if (BitConverter.IsLittleEndian && encodeForWire)
							Array.Reverse(bytes, index, 4);
						index += 4;
						// Velocity, encode as Kilometers/hour
						double v = mVelocity * 3.6;
						if (v == Double.NaN)
							bytes[index] = 0xff;
						else if (v > 254)
							bytes[index] = 254;
						else
							bytes[index] = (byte)Math.Round(v);
						break;
					case RTTOutMsgIds.DriverStatusNormal:
					case RTTOutMsgIds.DriverStatusOnBreak:
					case RTTOutMsgIds.DriverStatusOutOfVehicle:
					case RTTOutMsgIds.DriverLogoff:
						bytes = new byte[DriverStatusNormalLen];
						index = BuildHeader(bytes, encodeForWire);
						break;
					case RTTOutMsgIds.DriverMesgAck:
						bytes = new byte[DriverMesgAckLen];
						index = BuildHeader(bytes, encodeForWire);
						BitConverter.GetBytes(mMessageTag).CopyTo(bytes, index);
						break;
					case RTTOutMsgIds.DriverMesg:
						int txtLen = Math.Min(mTxTMessage.Length, MaxTxTMessageLen);
						bytes = new byte[DriverMesgLen + txtLen];
						index = BuildHeader(bytes, encodeForWire);
						Array.Copy(Encoding.ASCII.GetBytes(mTxTMessage), 0, bytes, index, txtLen);
						break;
					case RTTOutMsgIds.DriverLogon:
						int idLen = Math.Min(mDriverId.Length, MaxDriverIdLen);
						bytes = new byte[DriverLogonLen + idLen];
						index = BuildHeader(bytes, encodeForWire);
						Array.Copy(Encoding.ASCII.GetBytes(mDriverId), 0, bytes, index, idLen);
						break;
					case RTTOutMsgIds.EquipmentStatus:
						bytes = new byte[EquipmentStatusLen];
						index = BuildHeader(bytes, encodeForWire);
						bytes[index++] = (byte)mEquipmentMask;
						bytes[index] = (byte)mEquipmentState;
						break;
					case RTTOutMsgIds.FirmwareBuildNo:
						bytes = new byte[FirmwareBuildNoLen + (mCatalogue.Count * 2)];
						index = BuildHeader(bytes, encodeForWire);
						foreach (DeviceCatalogueInfo info in mCatalogue)
						{
							if ((byte)info.ProductId != 0 && info.BuildNo != 0)
							{
								bytes[index++] = (byte)info.ProductId;
								bytes[index++] = info.BuildNo;
							}
						}
						break;
					case RTTOutMsgIds.ResourceBuildNo:
						bytes = new byte[ResourceBuildNoLen];
						index = BuildHeader(bytes, encodeForWire);
						bytes[index++] = mRoutePatternVersion;
						bytes[index++] = mVehicleConfigVersion;
						bytes[index++] = mServiceAlertVersion;
						bytes[index++] = mDriverConfigVersion;
						break;
					case RTTOutMsgIds.APCLoading:
						bytes = new byte[APCLoadingLen];
						index = BuildHeader(bytes, encodeForWire);
						bytes[index] = mAPCLoading;
						break;
					}
				}
				catch (Exception e)
				{
					CNXLog.ErrorFormat("RTTMesg.GetBytes Id {0}, Length {1}, {2}", mMesgId, bytes.Length, e);
				}

			return bytes;
		}

		/// <summary>
		/// Adds the message header to the message byte array.
		/// </summary>
		/// <param name="message">Array of the message.</param>
		/// <param name="encodeForWire">Whether to ensure the values conatined in the array are encoded for IP transmission (Big Endian).</param>
		/// <returns>index of the next byte after the header.</returns>
		private int BuildHeader(byte[] message, bool encodeForWire)
		{
			int index = 0;
			// set message type
			byte[] b = BitConverter.GetBytes((ushort)mMesgId);
			if (encodeForWire && BitConverter.IsLittleEndian)
				Array.Reverse(b);
			b.CopyTo(message, index);
			index += 2;
			// set the Communications Address
			b = BitConverter.GetBytes(mCommsAddress);
			if (encodeForWire && BitConverter.IsLittleEndian)
				Array.Reverse(b);
			b.CopyTo(message, index);
			index += 2;
			// copy the messageNumber
			if (RequiresMesgNo)
				message[index++] = mMesgNo;

			return index;
		}

		/// <summary>
		/// Gets the message as an array of bytes ready to send to the server
		/// </summary>
		/// <param name="bytes">The array to insert the message into.</param>
		/// <param name="startIndex">Starting index for inserting the message.</param>
		/// <returns>Number of bytes inserted.</returns>
		/// <param name="encodeForWire">Whether to ensure the values conatined in the array are encoded for IP transmission (Big Endian).</param>
		/// <remarks>A negative value indicates that the message would not fit into the array and is the number or bytes that the array is short.</remarks>
		public int GetBytes(byte[] bytes, int startIndex, bool encodeForWire)
		{
			byte[] ourBytes = GetBytes(encodeForWire);

			int length = (bytes.Length - startIndex) - ourBytes.Length;
			if (length < 0)
				return length;

			ourBytes.CopyTo(bytes, startIndex);

			return ourBytes.Length;
		}

		public override string ToString()
		{
			string ret = null;
			try
			{
				object[] args;

				switch (mMesgId)
				{
					case RTTOutMsgIds.GPSNone:
					case RTTOutMsgIds.GPSNoFix:
						ret = string.Format("{0} Alarm {1}", mMesgId, mAlarm);
						break;
					case RTTOutMsgIds.GPSBadFix:
					case RTTOutMsgIds.GPSGoodFix:
						args = new object[] { mMesgId, mError, mAlarm, mLat, mLong, mVelocity };
						ret = string.Format("{0} Error {1} Alarm {2} {3}, {4}, velocity {5}", args);
						break;
					case RTTOutMsgIds.DriverStatusNormal:
					case RTTOutMsgIds.DriverStatusOnBreak:
					case RTTOutMsgIds.DriverStatusOutOfVehicle:
					case RTTOutMsgIds.DriverLogoff:
						ret = string.Format("{0}", mMesgId);
						break;
					case RTTOutMsgIds.DriverMesgAck:
						ret = string.Format("{0} {1}", mMesgId, mMessageTag);
						break;
					case RTTOutMsgIds.DriverMesg:
						ret = string.Format("{0} ({1}) {2}", mMesgId, mTxTMessage.Length, mTxTMessage);
						break;
					case RTTOutMsgIds.DriverLogon:
						ret = string.Format("{0} ({1}) {2}", mMesgId, mDriverId.Length, mDriverId);
						break;
					case RTTOutMsgIds.EquipmentStatus:
						ret = string.Format("{0} {1} [{2}]", mMesgId, mEquipmentMask, mEquipmentState);
						break;
					case RTTOutMsgIds.FirmwareBuildNo:
						StringBuilder sb = new StringBuilder(string.Format("{0}", mMesgId));
						foreach (DeviceCatalogueInfo info in mCatalogue)
						{
							if ((byte)info.ProductId != 0 && info.BuildNo != 0)
								sb.AppendFormat(" {0}:{1}", info.ProductId, info.BuildNo);
						}
						ret = sb.ToString();
						break;
					case RTTOutMsgIds.ResourceBuildNo:
						args = new object[] { mMesgId, mRoutePatternVersion, mVehicleConfigVersion, mServiceAlertVersion, mDriverConfigVersion };
						ret = string.Format("{0} RP {1}, Vehicle {2}, Alerts {3}, Driver {4}", args);
						break;
					case RTTOutMsgIds.APCLoading:
						ret = string.Format("{0} {1}", mMesgId, mAPCLoading);
						break;
					default:
						ret = string.Format("Unknown message Id {0}", mMesgId);
						break;
				}
			}
			catch (Exception e)
			{
				ret = e.Message;
			}
			return ret;
		}
	}
}
